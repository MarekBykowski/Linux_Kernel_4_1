--- Isolating a core from the Linux Scheduler ---

Say, I want to isolate core7. Note the cores (another commonly used name
especially around the Linux kernel is cpu) are indexed 0 through
number_of_cpus-1. The steps are:
•	stop the system in Uboot prompt and run:
setenv bootargs 'root=/dev/nfs rw mem=2G console=ttyAMA0 ip=dhcp isolcpus=7 nohz_full=7 rcu_nocbs=7'
run bootcmd

•	mem=2G is safe enough though it should match the memory layout
configured/set in the ASE. 
•	saveenv causes the bootargs variable to gets flashed to the Uboot env used at
the time (Uboot has 2x of them, primary and secondary). We should remember to
set it back after done with the time shared XLF
•	isolcpus=7 should offload cpu7 from any user-space processes. Can you
confirm this is only for the user-space processes?

To check if it went through we should have no user-space tasks running on the
cpu7 (we can check that through  /proc/sched_debug). /proc/sched_debug isn’t
enabled by default. To enable one can run make menuconfig, search for
sched_debug and add it in to the config)
•	rcu_nocbs=7 defines that cpu7 should run no RCU callbacks. For it we have to
have CONFIG_RCU_NOCB_CPU defined. By default XLF kernel doesn’t have it set.  It
is only becoming enabled after CONFIG_RCU_EXPERT gets enabled.  

To check if rcu_nocbs takes effect… RCU callbacks of the cpu7 isolated should
get offloaded to rcuos/7 and rcuob/7 kthreads. I’m seeing them running on cpu0
(again from /proc/sched_debug):
rcuos/7    63       439.964522         3   120         0.000000         0.006731  0.000000 / 
rcuob/7    64       439.966420         3   120         0.000000         0.007394  0.000000 /
•	nohz_full=7 takes effect only in the kernels with CONFIG_NO_HZ_FULL set. Our
kernel is running CONFIG_NO_HZ_IDLE. With NO_HZ_FULL and nohz_full=7 kernel
shouldn’t interrupt the cpu7 for any of the tasks to run.

The CONFIG_NO_HZ_FULL=y Kconfig option causes the kernel to avoid
sending scheduling-clock interrupts to CPUs with a single runnable task,
and such CPUs are said to be "adaptive-ticks CPUs".

By default, no CPU will be an adaptive-ticks CPU.  The "nohz_full="
boot parameter specifies the adaptive-ticks CPUs.  For example,
"nohz_full=1,6-8" says that CPUs 1, 6, 7, and 8 are to be adaptive-ticks
CPUs.

To check if it works first we should have no tick counts increasing on the cpu
isolated (/proc/interrupts) (More preciasely we should have a tick count per
second only when the core is running our app). With me arch_timer stopped firing
at the 285 count (below) for cpu7. 

Excerpt from /proc/interrupts (cutting in cpu6 through 12)

         CPU6       CPU7       CPU8       CPU9       CPU10      CPU11      CPU12                      
 1:          0          0          0          0          0          0          0
0          0          0         GICv3  25 Level     vgic
2:          0          0          0          0          0          0          0
0          0          0         GICv3  29 Level     arch_timer
3:      3294        285       1734       2739       1429       2087       1578
1356    GICv3  30 Level     arch_timer

•	also a comment on commonly met “isolcpus=0-6 nohz_full=0-6 rcu_nocbs=0-6”
below. It doesn’t reroute the IRQs away off cpu0. To achive that I think we
should look around IRQ affinity, part of the GIC driver routines.
